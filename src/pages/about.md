---
layout: "../layouts/BlogPost.astro"
title: "About"
description: "Who are you exactly?"
updatedDate: "Januray 03 2023"
---


## Me

I'm a Software Engineer from Saudi Arabia. Got into programming in 2016 by modding World Of Warcraft Private Servers where I fiddled around with SQL, C++, and x86 Assembly. After that, I got a BsC in Software Engineering from King Fahd University for Petroleum in Saudi Arabia and started with fullstack web, Flutter, and Rust along the way. And right now I spend my days thinking about tools, creating side-projects, and writing this blog.


## This blog
I started this blog for two reasons:

1. I wanted a space to share my thoughts

    I began writing my daily thoughts about programming languages and software development in general on 2023/01/01 in [Obsidian](https://obsidian.md/) and I wanted a place to share them. I've considered Twitter & Mastadon for this, but these types of platforms seem better suited to **hot takes** nowadays (which is fine) rather than thoughts.

2. I want to advocate for good software and tools that make software development better

    There is this common thought that programming languages (PL), frameworks, and libraries are *just tools* for the developer to use. This cognitive space has many ideas:
    - You should pick whatever PL/editor/framework you're comfortable with
    - You should pick the right tool for the job
    - There are always trade-offs for each tool. Some tools are better for GUI's others are better for Parsers.

    I disagree with most of this. I think there are *superior* tools that make development better in every way without making trade-offs. Wheather these tools exist right now or might exist I do not know. However, thoughout this blog, I'll provide arugments on *why and how such tools can exist, and why the software industry should move on to them*. I don't want to spill out everything here, but as a starter point: *Tools that advocate for the creation of human-interpretable and machine-interpretable computational models and provide an easy way to do so are strictly better than tools that don't*. You might think about this in terms of features such as a type-system, OOP, state machines, or various concurrency models. But the rabbit-hole goes much, *much* deeper.

    Overall, I think many in the software industry are ignorant of the true power and impact of tools, even in this age of of JS/TS framework hype and new PL's like Rust, Go, Zig, and Nim. We barely scratched the surface of software design.

    In essence, I want to reach the Nirvana of PL and software in this blog. (Which might be non-existence and we'll just have the power to communicate to a (super)human-level inteliegence via thought to make our software, if software's a thing anymore.)

### This blog might look a little off to you. This is on purpose, try to figure out why!